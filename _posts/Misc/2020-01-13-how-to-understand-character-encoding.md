---
layout: post
title: "谈一谈对字符编码的理解"
categories: "Misc"
---

#### 0x00 前言

这篇文章是基于自己的认知理解总结出来的，希望可以帮助其他人更好的理解字符编码的应用；如果文章中有理解错误的地方还请各位指点

简单罗列了一些常见的场景：

* 文件、页面乱码
* 对于某些漏洞场景的理解
* 程序中的字符编码报错

网上可以搜索到很多关于字符编码的理论知识介绍，常见的字符编码集、编码规范、大小端、高低代理等信息

这里主要分享如何更好的理解字符集编码，通过该认知可以解决大部分场景的编码问题

#### 0x01 unicode、utf8

unicode： 一个编码集，定义code point对应每个唯一的字符。code point为对应的unicode十六进制，例如：土字对应的码点为：U+571F；个人理解通过这对应的码点去展示对应的字符：浏览器、终端、文件等

utf8: 是针对unicode的一种实现方式。也就是编码unicode码点为对应的二进制序列，这里会使用utf8约定好的编码规则(使用多少字节存储、什么情况下补0、高低代理等等)，此处不详细展开，这里以`土`为例，简单阐述编码过程：

* 571F将转换为二进制：01010111 00011111
* 通过utf8的编码规则，会获得二进制：11100101 10011100 10011111
* 二进制对应的十六进制为：E5 9C 9F

最后得到的这个十六进制即为utf8编码下`土`字的具体存储表现，这样在磁盘、网络、内存都以这3个字节去传输，而不是以unicode的码点`571f`进行传输的。

#### 0x02 编码、解码

上面的实例即为UTF8的编码过程，而解码则正好相反

解码过程： 针对特定的二进制数据，使用utf8的编码约定去获取对应的unicode码点

Ps：这里解码的时候特定部分有特定的范围，常见的就是python碰到中文时的编码报错以及mysql中截断场景，都有检测到不属于该字符集的编码范围

#### 0x03 总结

utf8、GBK、iso-8859-1等都为具体的编码方式，都可以理解为：<strong>unicode码点与特定的十六进制序列映射</strong>

传输、存储的数据都是编码后的数据，而非unicode码点

编码和解码的过程相当于按照每个编码表，找映射的过程：

* 编码： unicode码点  --->  十六进制序列
* 解码： 十六进制序列  --->  unicode码点

而unicode将决定看到的字符是什么样子的

如果一个十六进制序列，使用了错误的编码方式去解码，那么会：

* 在解码过程中直接报错，因为不属于该编码方式的范围
* 最后解码出来的unicode显示为乱码



